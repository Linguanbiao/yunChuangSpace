{"ast":null,"code":"// //事件总线, 事件总线也是一种组件之间的通信方式，非常的灵活， 不只是说父子组件之间，各种关系的组件之间的通信都可以通过事件总线实现\n// const listeners = {}\n// export default {\n//     // 监听某个事件\n//     $on(eventName, handler) {\n//         if (!listeners[eventName]) {\n//             listeners[eventName] = new Set();\n//         }\n//         // 不止一个函数在监听该事件， 这里为该事件多添加一个监听操作函数\n//         listeners[eventName].add(handler);\n//     },\n//     // 删除一个见监听事件\n//     $off(eventName, handler) {\n//         if (!listeners[eventName]) {\n//             return\n//         }\n//         // 删除该事件的一个监听操作\n//         listeners[eventName].delete(handler);\n//     },\n//     //触发一个事件\n//     $emit(eventName, ...args) {\n//         if (!listeners[eventName]) {\n//             return\n//         }\n//         // 触发一个监听事件，那么所有监听了这个事件的操作都会触发\n//         for (const handler of listeners[eventName]) {\n//             handler(...args)\n//         }\n//     }\n// }\n\n/**\n * 事件总线还有下面这样一种实现方法，就是 vue 里面自动实现的上面 $on $off $emit 三个犯法，不需要我们自己封装\n * 事件名： mainScroll \n * 含义： 主区域滚动条位置变化后触发\n * 参数:\n * - 滚动的 dom 元素， 如果是undefined ， 则便是 dom 元素已经不存在\n *\n * \n * 事件名: setMianScroll\n * 含义: 当需要设置主区域的滚动条的位置时触发\n * 参数:\n * - 期望的滚动高度\n */\nimport Vue from \"vue\";\nvar app = new Vue({});\nVue.prototype.$bus = app; // 这样在 Vue 原型上注册可以让 vue 内部组件随意调用\n\nexport default app; // 导出 app 这样就可以让 js 等也调用","map":{"version":3,"names":["Vue","app","prototype","$bus"],"sources":["/Users/linwinwin/Desktop/mysit2/mysite-client/src/eventBus.js"],"sourcesContent":["// //事件总线, 事件总线也是一种组件之间的通信方式，非常的灵活， 不只是说父子组件之间，各种关系的组件之间的通信都可以通过事件总线实现\n\n// const listeners = {}\n// export default {\n//     // 监听某个事件\n//     $on(eventName, handler) {\n//         if (!listeners[eventName]) {\n//             listeners[eventName] = new Set();\n//         }\n//         // 不止一个函数在监听该事件， 这里为该事件多添加一个监听操作函数\n//         listeners[eventName].add(handler);\n//     },\n//     // 删除一个见监听事件\n//     $off(eventName, handler) {\n//         if (!listeners[eventName]) {\n//             return\n//         }\n//         // 删除该事件的一个监听操作\n//         listeners[eventName].delete(handler);\n\n//     },\n//     //触发一个事件\n//     $emit(eventName, ...args) {\n//         if (!listeners[eventName]) {\n//             return\n//         }\n//         // 触发一个监听事件，那么所有监听了这个事件的操作都会触发\n//         for (const handler of listeners[eventName]) {\n//             handler(...args)\n//         }\n//     }\n// }\n\n/**\n * 事件总线还有下面这样一种实现方法，就是 vue 里面自动实现的上面 $on $off $emit 三个犯法，不需要我们自己封装\n * 事件名： mainScroll \n * 含义： 主区域滚动条位置变化后触发\n * 参数:\n * - 滚动的 dom 元素， 如果是undefined ， 则便是 dom 元素已经不存在\n *\n * \n * 事件名: setMianScroll\n * 含义: 当需要设置主区域的滚动条的位置时触发\n * 参数:\n * - 期望的滚动高度\n */\nimport Vue from \"vue\";\nconst app = new Vue({})\nVue.prototype.$bus = app // 这样在 Vue 原型上注册可以让 vue 内部组件随意调用\n\nexport default app // 导出 app 这样就可以让 js 等也调用"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,GAAP,MAAgB,KAAhB;AACA,IAAMC,GAAG,GAAG,IAAID,GAAJ,CAAQ,EAAR,CAAZ;AACAA,GAAG,CAACE,SAAJ,CAAcC,IAAd,GAAqBF,GAArB,C,CAAyB;;AAEzB,eAAeA,GAAf,C,CAAmB"},"metadata":{},"sourceType":"module"}